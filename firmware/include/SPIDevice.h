/**
 * @file SPIDevice.h
 * @brief SPI device interface subsystem
 *
 * EDUCATIONAL NOTE: SPI (Serial Peripheral Interface) is a high-speed
 * synchronous serial communication protocol commonly used for:
 * - SD cards and flash memory
 * - High-speed sensors (accelerometers, gyroscopes)
 * - Display modules (TFT LCDs)
 * - ADC/DAC converters
 *
 * SPI Fundamentals:
 * - Four wires minimum: MOSI, MISO, SCK, CS
 * - Full-duplex: Simultaneous send and receive
 * - Master-slave architecture: ESP32 is master
 * - Much faster than I2C: Up to 80MHz on ESP32
 * - Point-to-point: Each slave needs separate CS line
 *
 * SPI Signals:
 * - MOSI (Master Out Slave In): Data from ESP32 to device
 * - MISO (Master In Slave Out): Data from device to ESP32
 * - SCK (Serial Clock): Clock signal generated by master
 * - CS (Chip Select): Active-low signal to select device
 *
 * How SPI works:
 * 1. Master pulls CS low (activates slave)
 * 2. Master generates clock on SCK
 * 3. Master sends data on MOSI, receives on MISO simultaneously
 * 4. Master pulls CS high (deactivates slave)
 *
 * This is a generic SPI device class that can be extended for specific
 * devices (accelerometers, displays, etc.)
 */

#ifndef SPI_DEVICE_H
#define SPI_DEVICE_H

#include <Arduino.h>
#include <SPI.h>
#include "RobotSubsystem.h"
#include "config.h"

/**
 * @class SPIDevice
 * @brief Generic SPI device interface with basic read/write operations
 *
 * EDUCATIONAL: This demonstrates SPI communication patterns. For real
 * projects, you'd extend this class for specific devices (e.g., IMU sensor).
 *
 * SPI Modes (CPOL/CPHA):
 * - Mode 0: CPOL=0, CPHA=0 (most common)
 * - Mode 1: CPOL=0, CPHA=1
 * - Mode 2: CPOL=1, CPHA=0
 * - Mode 3: CPOL=1, CPHA=1
 *
 * CPOL: Clock Polarity (idle state of clock)
 * CPHA: Clock Phase (when data is sampled)
 */
class SPIDevice : public RobotSubsystem {
public:
    /**
     * @brief Construct a new SPIDevice object
     *
     * EDUCATIONAL: Constructor sets SPI parameters but doesn't initialize
     * hardware. SPI bus setup happens in initialize().
     *
     * @param csPin Chip Select pin number
     * @param spiFrequency SPI clock frequency in Hz (default 1MHz)
     * @param spiMode SPI mode 0-3 (default 0)
     */
    SPIDevice(int csPin,
              uint32_t spiFrequency = 1000000,  // 1MHz default
              uint8_t spiMode = SPI_MODE0)
        : _csPin(csPin),
          _spiFrequency(spiFrequency),
          _spiMode(spiMode),
          _transferCount(0),
          _errorCount(0),
          _testRegisterValue(0)
    {
        // Constructor initializes configuration only
    }

    /**
     * @brief Initialize SPI bus and device
     *
     * EDUCATIONAL: This method:
     * 1. Configures CS pin as output
     * 2. Initializes SPI bus with MOSI, MISO, SCK pins
     * 3. Sets SPI parameters (frequency, mode, bit order)
     * 4. Tests device communication (if testable)
     *
     * @return true if initialization successful
     */
    bool initialize() override {
        Serial.print("[SPIDevice] Initializing SPI device on CS pin ");
        Serial.println(_csPin);

        // Configure chip select pin
        // EDUCATIONAL: CS pin must be set HIGH initially (inactive state)
        // SPI devices are activated when CS goes LOW
        pinMode(_csPin, OUTPUT);
        digitalWrite(_csPin, HIGH);

        Serial.print("[SPIDevice] CS pin ");
        Serial.print(_csPin);
        Serial.println(" configured (HIGH = inactive)");

        // Initialize SPI bus
        // EDUCATIONAL: The ESP32 has multiple SPI buses (VSPI, HSPI)
        // We use the default VSPI bus here
        _spi.begin(SPI_SCK_PIN, SPI_MISO_PIN, SPI_MOSI_PIN, _csPin);

        Serial.print("[SPIDevice] SPI bus initialized: SCK=");
        Serial.print(SPI_SCK_PIN);
        Serial.print(", MISO=");
        Serial.print(SPI_MISO_PIN);
        Serial.print(", MOSI=");
        Serial.println(SPI_MOSI_PIN);

        // Display SPI configuration
        Serial.print("[SPIDevice] SPI frequency: ");
        Serial.print(_spiFrequency / 1000);
        Serial.println(" kHz");
        Serial.print("[SPIDevice] SPI mode: ");
        Serial.println(_spiMode);

        // Test SPI communication (simple loopback test)
        // EDUCATIONAL: Without a real device, we can't truly test,
        // but we can verify SPI bus doesn't crash
        if (performSelfTest()) {
            _isInitialized = true;
            Serial.println("[SPIDevice] ✓ SPI device initialized");
            return true;
        } else {
            Serial.println("[SPIDevice] ⚠ SPI initialized but self-test inconclusive");
            Serial.println("[SPIDevice] This is expected without physical SPI device");
            _isInitialized = true;  // Allow operation anyway for demo
            return true;
        }
    }

    /**
     * @brief Update device state (called every loop iteration)
     *
     * EDUCATIONAL: For SPI devices, update() might:
     * - Read sensor data periodically
     * - Check device status registers
     * - Handle interrupts from device
     *
     * This generic implementation does periodic test reads.
     */
    void update() override {
        if (!_isInitialized || !_isEnabled) {
            return;
        }

        // Perform periodic test operation (every 2 seconds)
        if (hasIntervalElapsed(2000)) {
            // Read a test register (example: register 0x00)
            uint8_t value = readRegister(0x00);

            if (DEBUG_VERBOSE) {
                Serial.print("[SPIDevice] Test read: reg 0x00 = 0x");
                Serial.println(value, HEX);
            }

            _testRegisterValue = value;
            updateTimestamp();
        }
    }

    /**
     * @brief Check if device is ready
     *
     * @return true if initialized
     */
    bool isReady() override {
        return _isInitialized;
    }

    /**
     * @brief Get current status string
     *
     * @return Status with transfer statistics
     */
    String getStatus() override {
        if (!_isInitialized) {
            return "SPIDevice: Not initialized";
        }

        char buffer[128];
        snprintf(buffer, sizeof(buffer),
                 "SPIDevice: CS=%d, freq=%lukHz [transfers=%lu, errors=%lu]",
                 _csPin, _spiFrequency / 1000, _transferCount, _errorCount);
        return String(buffer);
    }

    /**
     * @brief Get subsystem name
     *
     * @return Subsystem identifier
     */
    const char* getName() const override {
        return "SPIDevice";
    }

    /**
     * @brief Read a single byte from device register
     *
     * EDUCATIONAL: This is a common SPI pattern:
     * 1. Assert CS (pull low)
     * 2. Send register address with read bit
     * 3. Receive data byte
     * 4. Deassert CS (pull high)
     *
     * @param registerAddress Register to read from
     * @return Byte value read from register
     */
    uint8_t readRegister(uint8_t registerAddress) {
        // Begin SPI transaction with configured settings
        // EDUCATIONAL: SPISettings configures frequency, bit order, and mode
        _spi.beginTransaction(SPISettings(_spiFrequency, MSBFIRST, _spiMode));

        // Select device (CS low)
        digitalWrite(_csPin, LOW);

        // Send register address with read bit set (bit 7 = 1)
        // EDUCATIONAL: Many SPI devices use bit 7 to indicate read (1) vs write (0)
        _spi.transfer(registerAddress | 0x80);

        // Read data byte
        uint8_t value = _spi.transfer(0x00);  // Send dummy byte, receive data

        // Deselect device (CS high)
        digitalWrite(_csPin, HIGH);

        // End SPI transaction
        _spi.endTransaction();

        _transferCount++;
        return value;
    }

    /**
     * @brief Write a single byte to device register
     *
     * EDUCATIONAL: SPI write pattern:
     * 1. Assert CS
     * 2. Send register address with write bit
     * 3. Send data byte
     * 4. Deassert CS
     *
     * @param registerAddress Register to write to
     * @param value Byte value to write
     */
    void writeRegister(uint8_t registerAddress, uint8_t value) {
        _spi.beginTransaction(SPISettings(_spiFrequency, MSBFIRST, _spiMode));

        digitalWrite(_csPin, LOW);

        // Send register address with write bit clear (bit 7 = 0)
        _spi.transfer(registerAddress & 0x7F);

        // Send data byte
        _spi.transfer(value);

        digitalWrite(_csPin, HIGH);

        _spi.endTransaction();

        _transferCount++;

        if (DEBUG_VERBOSE) {
            Serial.print("[SPIDevice] Write: reg 0x");
            Serial.print(registerAddress, HEX);
            Serial.print(" = 0x");
            Serial.println(value, HEX);
        }
    }

    /**
     * @brief Read multiple bytes from device
     *
     * EDUCATIONAL: Burst read is more efficient than multiple single reads.
     * Useful for reading sensor data (e.g., 6 bytes for 3-axis accelerometer).
     *
     * @param registerAddress Starting register address
     * @param buffer Buffer to store read data
     * @param length Number of bytes to read
     */
    void readBytes(uint8_t registerAddress, uint8_t* buffer, size_t length) {
        _spi.beginTransaction(SPISettings(_spiFrequency, MSBFIRST, _spiMode));

        digitalWrite(_csPin, LOW);

        // Send register address with read bit
        _spi.transfer(registerAddress | 0x80);

        // Read multiple bytes
        for (size_t i = 0; i < length; i++) {
            buffer[i] = _spi.transfer(0x00);
        }

        digitalWrite(_csPin, HIGH);

        _spi.endTransaction();

        _transferCount++;

        if (DEBUG_VERBOSE) {
            Serial.print("[SPIDevice] Read ");
            Serial.print(length);
            Serial.print(" bytes from reg 0x");
            Serial.println(registerAddress, HEX);
        }
    }

    /**
     * @brief Write multiple bytes to device
     *
     * EDUCATIONAL: Burst write for efficient multi-byte transfers.
     *
     * @param registerAddress Starting register address
     * @param buffer Buffer containing data to write
     * @param length Number of bytes to write
     */
    void writeBytes(uint8_t registerAddress, const uint8_t* buffer, size_t length) {
        _spi.beginTransaction(SPISettings(_spiFrequency, MSBFIRST, _spiMode));

        digitalWrite(_csPin, LOW);

        // Send register address with write bit
        _spi.transfer(registerAddress & 0x7F);

        // Write multiple bytes
        for (size_t i = 0; i < length; i++) {
            _spi.transfer(buffer[i]);
        }

        digitalWrite(_csPin, HIGH);

        _spi.endTransaction();

        _transferCount++;
    }

    /**
     * @brief Get SPI transfer count
     *
     * @return Number of SPI transactions performed
     */
    unsigned long getTransferCount() const {
        return _transferCount;
    }

    /**
     * @brief Get error count
     *
     * @return Number of SPI errors detected
     */
    unsigned long getErrorCount() const {
        return _errorCount;
    }

    /**
     * @brief Get last test register value
     *
     * @return Value from periodic test reads
     */
    uint8_t getTestRegisterValue() const {
        return _testRegisterValue;
    }

private:
    /**
     * @brief Perform basic SPI communication test
     *
     * EDUCATIONAL: Without a real device, we can't do much here.
     * With a real device, you'd:
     * - Read a WHO_AM_I register (device ID)
     * - Write/read a test pattern
     * - Verify device responds correctly
     *
     * @return true if test passed (or inconclusive)
     */
    bool performSelfTest() {
        Serial.println("[SPIDevice] Performing SPI self-test...");

        // Try a simple read (will return random/invalid data without real device)
        uint8_t testValue = readRegister(0x00);

        Serial.print("[SPIDevice] Test read from register 0x00: 0x");
        Serial.println(testValue, HEX);

        // With no device connected, we can't verify the value
        // But if SPI didn't crash, bus is working
        Serial.println("[SPIDevice] ✓ SPI bus functional");
        Serial.println("[SPIDevice] Note: Connect a real SPI device for full testing");

        return true;  // Inconclusive but allow operation
    }

    // Private member variables
    SPIClass _spi;                  ///< SPI bus object (VSPI)
    int _csPin;                     ///< Chip Select pin
    uint32_t _spiFrequency;         ///< SPI clock frequency in Hz
    uint8_t _spiMode;               ///< SPI mode (0-3)
    unsigned long _transferCount;   ///< Number of SPI transfers
    unsigned long _errorCount;      ///< Number of errors
    uint8_t _testRegisterValue;     ///< Last test register read value
};

#endif // SPI_DEVICE_H
